///
/// Auto-generated by Stone, do not modify.
///

#import "DBXFILESLookupError.h"
#import "DBXStoneSerializers.h"
#import "DBXStoneValidators.h"

@implementation DBXFILESLookupError 

@synthesize malformedPath = _malformedPath;

- (instancetype)initWithMalformedPath:(NSString *)malformedPath {
    self = [super init];
    if (self) {
        _tag = DBXFILESLookupErrorMalformedPath;
        _malformedPath = malformedPath;
    }
    return self;
}

- (instancetype)initWithNotFound {
    self = [super init];
    if (self) {
        _tag = DBXFILESLookupErrorNotFound;
    }
    return self;
}

- (instancetype)initWithNotFile {
    self = [super init];
    if (self) {
        _tag = DBXFILESLookupErrorNotFile;
    }
    return self;
}

- (instancetype)initWithNotFolder {
    self = [super init];
    if (self) {
        _tag = DBXFILESLookupErrorNotFolder;
    }
    return self;
}

- (instancetype)initWithRestrictedContent {
    self = [super init];
    if (self) {
        _tag = DBXFILESLookupErrorRestrictedContent;
    }
    return self;
}

- (instancetype)initWithOther {
    self = [super init];
    if (self) {
        _tag = DBXFILESLookupErrorOther;
    }
    return self;
}

- (BOOL)isMalformedPath {
    return _tag == DBXFILESLookupErrorMalformedPath;
}

- (BOOL)isNotFound {
    return _tag == DBXFILESLookupErrorNotFound;
}

- (BOOL)isNotFile {
    return _tag == DBXFILESLookupErrorNotFile;
}

- (BOOL)isNotFolder {
    return _tag == DBXFILESLookupErrorNotFolder;
}

- (BOOL)isRestrictedContent {
    return _tag == DBXFILESLookupErrorRestrictedContent;
}

- (BOOL)isOther {
    return _tag == DBXFILESLookupErrorOther;
}

- (NSString *)getTagName {
    switch (_tag) {
        case DBXFILESLookupErrorMalformedPath:
           return @"DBXFILESLookupErrorMalformedPath";
        case DBXFILESLookupErrorNotFound:
           return @"DBXFILESLookupErrorNotFound";
        case DBXFILESLookupErrorNotFile:
           return @"DBXFILESLookupErrorNotFile";
        case DBXFILESLookupErrorNotFolder:
           return @"DBXFILESLookupErrorNotFolder";
        case DBXFILESLookupErrorRestrictedContent:
           return @"DBXFILESLookupErrorRestrictedContent";
        case DBXFILESLookupErrorOther:
           return @"DBXFILESLookupErrorOther";
    }

    @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an invalid value." userInfo:nil]);
}

- (NSString *)malformedPath {
    if (![self isMalformedPath]) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required `DBXFILESLookupErrorMalformedPath`, but was %@.", [self getTagName]];
    }
    return _malformedPath;
}

+ (NSDictionary *)serialize:(id)instance {
    return [DBXFILESLookupErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
    return [DBXFILESLookupErrorSerializer deserialize:dict];
}

- (NSString *)description {
    return [[DBXFILESLookupErrorSerializer serialize:self] description];
}

@end


@implementation DBXFILESLookupErrorSerializer 

+ (NSDictionary *)serialize:(DBXFILESLookupError *)valueObj {
    NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

    if ([valueObj isMalformedPath]) {
        if (valueObj.malformedPath) {
            jsonDict[@"malformed_path"] = valueObj.malformedPath;
        }
        jsonDict[@".tag"] = @"malformed_path";
    }
    else if ([valueObj isNotFound]) {
        jsonDict[@".tag"] = @"not_found";
    }
    else if ([valueObj isNotFile]) {
        jsonDict[@".tag"] = @"not_file";
    }
    else if ([valueObj isNotFolder]) {
        jsonDict[@".tag"] = @"not_folder";
    }
    else if ([valueObj isRestrictedContent]) {
        jsonDict[@".tag"] = @"restricted_content";
    }
    else if ([valueObj isOther]) {
        jsonDict[@".tag"] = @"other";
    }
    else {
        @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an invalid value." userInfo:nil]);
    }

    return jsonDict;
}

+ (DBXFILESLookupError *)deserialize:(NSDictionary *)valueDict {
    NSString *tag = valueDict[@".tag"];

    if ([tag isEqualToString:@"malformed_path"]) {
        NSString *malformedPath = valueDict[@"malformed_path"] ? valueDict[@"malformed_path"] : nil;
        return [[DBXFILESLookupError alloc] initWithMalformedPath:malformedPath];
    }
    else if ([tag isEqualToString:@"not_found"]) {
        return [[DBXFILESLookupError alloc] initWithNotFound];
    }
    else if ([tag isEqualToString:@"not_file"]) {
        return [[DBXFILESLookupError alloc] initWithNotFile];
    }
    else if ([tag isEqualToString:@"not_folder"]) {
        return [[DBXFILESLookupError alloc] initWithNotFolder];
    }
    else if ([tag isEqualToString:@"restricted_content"]) {
        return [[DBXFILESLookupError alloc] initWithRestrictedContent];
    }
    else if ([tag isEqualToString:@"other"]) {
        return [[DBXFILESLookupError alloc] initWithOther];
    }

    @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an invalid value." userInfo:nil]);
}

@end
