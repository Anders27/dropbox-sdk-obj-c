///
/// Auto-generated by Stone, do not modify.
///

#import "DBXFILESLookupError.h"
#import "DBXFILESRelocationError.h"
#import "DBXFILESWriteError.h"
#import "DBXStoneSerializers.h"
#import "DBXStoneValidators.h"

@implementation DBXFILESRelocationError 

- (instancetype)initWithFromLookup:(DBXFILESLookupError *)fromLookup {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorFromLookup;
        _fromLookup = fromLookup;
    }
    return self;
}

- (instancetype)initWithFromWrite:(DBXFILESWriteError *)fromWrite {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorFromWrite;
        _fromWrite = fromWrite;
    }
    return self;
}

- (instancetype)initWithTo:(DBXFILESWriteError *)to {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorTo;
        _to = to;
    }
    return self;
}

- (instancetype)initWithCantCopySharedFolder {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorCantCopySharedFolder;
    }
    return self;
}

- (instancetype)initWithCantNestSharedFolder {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorCantNestSharedFolder;
    }
    return self;
}

- (instancetype)initWithCantMoveFolderIntoItself {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorCantMoveFolderIntoItself;
    }
    return self;
}

- (instancetype)initWithTooManyFiles {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorTooManyFiles;
    }
    return self;
}

- (instancetype)initWithOther {
    self = [super init];
    if (self != nil) {
        _tag = DBXFILESRelocationErrorOther;
    }
    return self;
}

- (BOOL)isFromLookup {
    return _tag == DBXFILESRelocationErrorFromLookup;
}

- (BOOL)isFromWrite {
    return _tag == DBXFILESRelocationErrorFromWrite;
}

- (BOOL)isTo {
    return _tag == DBXFILESRelocationErrorTo;
}

- (BOOL)isCantCopySharedFolder {
    return _tag == DBXFILESRelocationErrorCantCopySharedFolder;
}

- (BOOL)isCantNestSharedFolder {
    return _tag == DBXFILESRelocationErrorCantNestSharedFolder;
}

- (BOOL)isCantMoveFolderIntoItself {
    return _tag == DBXFILESRelocationErrorCantMoveFolderIntoItself;
}

- (BOOL)isTooManyFiles {
    return _tag == DBXFILESRelocationErrorTooManyFiles;
}

- (BOOL)isOther {
    return _tag == DBXFILESRelocationErrorOther;
}

- (NSString *)getTagName {
    switch (_tag) {
        case DBXFILESRelocationErrorFromLookup:
           return @"DBXFILESRelocationErrorFromLookup";
        case DBXFILESRelocationErrorFromWrite:
           return @"DBXFILESRelocationErrorFromWrite";
        case DBXFILESRelocationErrorTo:
           return @"DBXFILESRelocationErrorTo";
        case DBXFILESRelocationErrorCantCopySharedFolder:
           return @"DBXFILESRelocationErrorCantCopySharedFolder";
        case DBXFILESRelocationErrorCantNestSharedFolder:
           return @"DBXFILESRelocationErrorCantNestSharedFolder";
        case DBXFILESRelocationErrorCantMoveFolderIntoItself:
           return @"DBXFILESRelocationErrorCantMoveFolderIntoItself";
        case DBXFILESRelocationErrorTooManyFiles:
           return @"DBXFILESRelocationErrorTooManyFiles";
        case DBXFILESRelocationErrorOther:
           return @"DBXFILESRelocationErrorOther";
    }

    @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an invalid value." userInfo:nil]);
}

- (DBXFILESLookupError *)fromLookup {
    if (_tag != DBXFILESRelocationErrorFromLookup) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required `DBXFILESRelocationErrorFromLookup`, but was %@.", [self getTagName]];
    }
    return _fromLookup;
}

- (DBXFILESWriteError *)fromWrite {
    if (_tag != DBXFILESRelocationErrorFromWrite) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required `DBXFILESRelocationErrorFromWrite`, but was %@.", [self getTagName]];
    }
    return _fromWrite;
}

- (DBXFILESWriteError *)to {
    if (_tag != DBXFILESRelocationErrorTo) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required `DBXFILESRelocationErrorTo`, but was %@.", [self getTagName]];
    }
    return _to;
}

+ (NSDictionary *)serialize:(id)obj {
    return [DBXFILESRelocationErrorSerializer serialize:obj];
}

+ (id)deserialize:(NSDictionary *)dict {
    return [DBXFILESRelocationErrorSerializer deserialize:dict];
}

- (NSString *)description {
    return [[DBXFILESRelocationErrorSerializer serialize:self] description];
}

@end


@implementation DBXFILESRelocationErrorSerializer 

+ (NSDictionary *)serialize:(DBXFILESRelocationError *)valueObj {
    NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

    if ([valueObj isFromLookup]) {
        jsonDict = [[DBXFILESLookupErrorSerializer serialize:valueObj.fromLookup] mutableCopy];
        jsonDict[@".tag"] = @"from_lookup";
    }
    else if ([valueObj isFromWrite]) {
        jsonDict = [[DBXFILESWriteErrorSerializer serialize:valueObj.fromWrite] mutableCopy];
        jsonDict[@".tag"] = @"from_write";
    }
    else if ([valueObj isTo]) {
        jsonDict = [[DBXFILESWriteErrorSerializer serialize:valueObj.to] mutableCopy];
        jsonDict[@".tag"] = @"to";
    }
    else if ([valueObj isCantCopySharedFolder]) {
        jsonDict[@".tag"] = @"cant_copy_shared_folder";
    }
    else if ([valueObj isCantNestSharedFolder]) {
        jsonDict[@".tag"] = @"cant_nest_shared_folder";
    }
    else if ([valueObj isCantMoveFolderIntoItself]) {
        jsonDict[@".tag"] = @"cant_move_folder_into_itself";
    }
    else if ([valueObj isTooManyFiles]) {
        jsonDict[@".tag"] = @"too_many_files";
    }
    else if ([valueObj isOther]) {
        jsonDict[@".tag"] = @"other";
    }
    else {
        @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an invalid value." userInfo:nil]);
    }

    return jsonDict;
}

+ (DBXFILESRelocationError *)deserialize:(NSDictionary *)valueDict {
    NSString *tag = valueDict[@".tag"];

    if ([tag isEqualToString:@"from_lookup"]) {
        DBXFILESLookupError *fromLookup = [DBXFILESLookupErrorSerializer deserialize:valueDict[@"from_lookup"]];
        return [[DBXFILESRelocationError alloc] initWithFromLookup:fromLookup];
    }
    else if ([tag isEqualToString:@"from_write"]) {
        DBXFILESWriteError *fromWrite = [DBXFILESWriteErrorSerializer deserialize:valueDict[@"from_write"]];
        return [[DBXFILESRelocationError alloc] initWithFromWrite:fromWrite];
    }
    else if ([tag isEqualToString:@"to"]) {
        DBXFILESWriteError *to = [DBXFILESWriteErrorSerializer deserialize:valueDict[@"to"]];
        return [[DBXFILESRelocationError alloc] initWithTo:to];
    }
    else if ([tag isEqualToString:@"cant_copy_shared_folder"]) {
        return [[DBXFILESRelocationError alloc] initWithCantCopySharedFolder];
    }
    else if ([tag isEqualToString:@"cant_nest_shared_folder"]) {
        return [[DBXFILESRelocationError alloc] initWithCantNestSharedFolder];
    }
    else if ([tag isEqualToString:@"cant_move_folder_into_itself"]) {
        return [[DBXFILESRelocationError alloc] initWithCantMoveFolderIntoItself];
    }
    else if ([tag isEqualToString:@"too_many_files"]) {
        return [[DBXFILESRelocationError alloc] initWithTooManyFiles];
    }
    else if ([tag isEqualToString:@"other"]) {
        return [[DBXFILESRelocationError alloc] initWithOther];
    }

    @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an invalid value." userInfo:nil]);
}

@end
