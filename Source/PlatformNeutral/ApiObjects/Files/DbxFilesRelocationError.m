///
/// Auto-generated by Stone, do not modify.
///

#import "DbxFilesLookupError.h"
#import "DbxFilesRelocationError.h"
#import "DbxFilesWriteError.h"
#import "DbxStoneSerializers.h"
#import "DbxStoneValidators.h"

@implementation DbxFilesRelocationError 

- (instancetype)initWithFromLookup:(DbxFilesLookupError *)fromLookup {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorFromLookup;
        _fromLookup = fromLookup;
    }
    return self;
}

- (instancetype)initWithFromWrite:(DbxFilesWriteError *)fromWrite {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorFromWrite;
        _fromWrite = fromWrite;
    }
    return self;
}

- (instancetype)initWithTo:(DbxFilesWriteError *)to {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorTo;
        _to = to;
    }
    return self;
}

- (instancetype)initWithCantCopySharedFolder {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorCantCopySharedFolder;
    }
    return self;
}

- (instancetype)initWithCantNestSharedFolder {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorCantNestSharedFolder;
    }
    return self;
}

- (instancetype)initWithCantMoveFolderIntoItself {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorCantMoveFolderIntoItself;
    }
    return self;
}

- (instancetype)initWithTooManyFiles {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorTooManyFiles;
    }
    return self;
}

- (instancetype)initWithOther {
    self = [super init];
    if (self != nil) {
        _tag = (FilesRelocationErrorTag)FilesRelocationErrorOther;
    }
    return self;
}

- (BOOL)isFromLookup {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorFromLookup;
}

- (BOOL)isFromWrite {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorFromWrite;
}

- (BOOL)isTo {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorTo;
}

- (BOOL)isCantCopySharedFolder {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorCantCopySharedFolder;
}

- (BOOL)isCantNestSharedFolder {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorCantNestSharedFolder;
}

- (BOOL)isCantMoveFolderIntoItself {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorCantMoveFolderIntoItself;
}

- (BOOL)isTooManyFiles {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorTooManyFiles;
}

- (BOOL)isOther {
    return _tag == (FilesRelocationErrorTag)FilesRelocationErrorOther;
}

- (NSString *)getTagName {
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorFromLookup) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorFromLookup";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorFromWrite) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorFromWrite";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorTo) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorTo";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorCantCopySharedFolder) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorCantCopySharedFolder";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorCantNestSharedFolder) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorCantNestSharedFolder";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorCantMoveFolderIntoItself) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorCantMoveFolderIntoItself";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorTooManyFiles) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorTooManyFiles";
    }
    if (_tag == (FilesRelocationErrorTag)FilesRelocationErrorOther) {
        return @"(FilesRelocationErrorTag)FilesRelocationErrorOther";
    }

    @throw([NSException exceptionWithName:@"InvalidTagEnum" reason:@"Supplied tag enum has an invalid value." userInfo:nil]);
}

- (DbxFilesLookupError *)fromLookup {
    if (_tag != (FilesRelocationErrorTag)FilesRelocationErrorFromLookup) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required (FilesRelocationErrorTag)FilesRelocationErrorFromLookup, but was %@.", [self getTagName]];
    }
    return _fromLookup;
}

- (DbxFilesWriteError *)fromWrite {
    if (_tag != (FilesRelocationErrorTag)FilesRelocationErrorFromWrite) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required (FilesRelocationErrorTag)FilesRelocationErrorFromWrite, but was %@.", [self getTagName]];
    }
    return _fromWrite;
}

- (DbxFilesWriteError *)to {
    if (_tag != (FilesRelocationErrorTag)FilesRelocationErrorTo) {
        [NSException raise:@"IllegalStateException" format:@"Invalid tag: required (FilesRelocationErrorTag)FilesRelocationErrorTo, but was %@.", [self getTagName]];
    }
    return _to;
}

+ (NSDictionary *)serialize:(id)obj {
    return [DbxFilesRelocationErrorSerializer serialize:obj];
}

+ (id)deserialize:(NSDictionary *)dict {
    return [DbxFilesRelocationErrorSerializer deserialize:dict];
}

- (NSString *)description {
    return [[DbxFilesRelocationErrorSerializer serialize:self] description];
}

@end


@implementation DbxFilesRelocationErrorSerializer 

+ (NSDictionary *)serialize:(DbxFilesRelocationError *)valueObj {
    NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

    if ([valueObj isFromLookup]) {
        jsonDict = [[DbxFilesLookupErrorSerializer serialize:valueObj.fromLookup] mutableCopy];
        jsonDict[@".tag"] = @"from_lookup";
    }
    else if ([valueObj isFromWrite]) {
        jsonDict = [[DbxFilesWriteErrorSerializer serialize:valueObj.fromWrite] mutableCopy];
        jsonDict[@".tag"] = @"from_write";
    }
    else if ([valueObj isTo]) {
        jsonDict = [[DbxFilesWriteErrorSerializer serialize:valueObj.to] mutableCopy];
        jsonDict[@".tag"] = @"to";
    }
    else if ([valueObj isCantCopySharedFolder]) {
        jsonDict[@".tag"] = @"cant_copy_shared_folder";
    }
    else if ([valueObj isCantNestSharedFolder]) {
        jsonDict[@".tag"] = @"cant_nest_shared_folder";
    }
    else if ([valueObj isCantMoveFolderIntoItself]) {
        jsonDict[@".tag"] = @"cant_move_folder_into_itself";
    }
    else if ([valueObj isTooManyFiles]) {
        jsonDict[@".tag"] = @"too_many_files";
    }
    else if ([valueObj isOther]) {
        jsonDict[@".tag"] = @"other";
    }
    else {
        @throw([NSException exceptionWithName:@"InvalidTagEnum" reason:@"Supplied tag enum has an invalid value." userInfo:nil]);
    }

    return jsonDict;
}

+ (DbxFilesRelocationError *)deserialize:(NSDictionary *)valueDict {
    NSString *tag = valueDict[@".tag"];

    if ([tag isEqualToString:@"from_lookup"]) {
        DbxFilesLookupError *fromLookup = [DbxFilesLookupErrorSerializer deserialize:valueDict[@"from_lookup"]];
        return [[DbxFilesRelocationError alloc] initWithFromLookup:fromLookup];
    }
    if ([tag isEqualToString:@"from_write"]) {
        DbxFilesWriteError *fromWrite = [DbxFilesWriteErrorSerializer deserialize:valueDict[@"from_write"]];
        return [[DbxFilesRelocationError alloc] initWithFromWrite:fromWrite];
    }
    if ([tag isEqualToString:@"to"]) {
        DbxFilesWriteError *to = [DbxFilesWriteErrorSerializer deserialize:valueDict[@"to"]];
        return [[DbxFilesRelocationError alloc] initWithTo:to];
    }
    if ([tag isEqualToString:@"cant_copy_shared_folder"]) {
        return [[DbxFilesRelocationError alloc] initWithCantCopySharedFolder];
    }
    if ([tag isEqualToString:@"cant_nest_shared_folder"]) {
        return [[DbxFilesRelocationError alloc] initWithCantNestSharedFolder];
    }
    if ([tag isEqualToString:@"cant_move_folder_into_itself"]) {
        return [[DbxFilesRelocationError alloc] initWithCantMoveFolderIntoItself];
    }
    if ([tag isEqualToString:@"too_many_files"]) {
        return [[DbxFilesRelocationError alloc] initWithTooManyFiles];
    }
    if ([tag isEqualToString:@"other"]) {
        return [[DbxFilesRelocationError alloc] initWithOther];
    }

    @throw([NSException exceptionWithName:@"InvalidTagEnum" reason:@"Supplied tag enum has an invalid value." userInfo:nil]);
}

@end
